{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/protect-self-hosted-assets-with-firewalls-and-cors","result":{"data":{"post":{"__typename":"MdxPost","slug":"/protect-self-hosted-assets-with-firewalls-and-cors","title":"Protect self-hosted assets with firewalls and CORS","date":"April 25th, 2020","tags":null,"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Protect self-hosted assets with firewalls and CORS\",\n  \"date\": \"2020-04-25T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I self host map tiles and other large assets for use by my own projects, but in\\ngeneral I don't want to host map data for anyone on the internet. By default,\\nhosting a server with map tiles open to the internet means that anyone could\\npoint to your URL and serve a web map using your map data.\"), mdx(\"p\", null, \"I've created open-source scripts [] to generate map tiles, in order to enable\\ndevelopers to self host map assets as easily as possible, but I don't want to\\npay for them to use my tiles directly.\"), mdx(\"p\", null, \"I host my map assets partially on a Google Cloud f1-micro instance, and\\npartially on AWS S3 directly. For both, I put Cloudflare in front so that I can\\nbenefit from their caching and lower my bandwidth costs.\"), mdx(\"h2\", {\n    \"id\": \"allow-only-traffic-from-cloudflare\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#allow-only-traffic-from-cloudflare\",\n    \"aria-label\": \"allow only traffic from cloudflare permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Allow only traffic from Cloudflare\"), mdx(\"p\", null, \"I use Cloudflare to make load times faster for users through their CDN, and to\\nkeep my bandwidth costs as low as possible by leveraging their free caching.\\nHowever, this strategy only works if all your traffic is indeed coming through\\nCloudflare.\"), mdx(\"p\", null, \"Both AWS S3 and a Google Cloud Compute instance have default URLs for access.\\nFor S3, if you create the bucket in US-East-1, it'll be\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"https://s3.amazonaws.com/BUCKET_NAME\"), \". For Google Cloud, it's the external IP\\naddress. Traffic coming directly to either of those won't be proxied by\\nCloudflare, and thus won't be cached. The solution is to only allow access from\\nCloudflare's IP addresses, because when Cloudflare proxies traffic for you, it\\nmeans that your server sees Cloudflare's IP address as the source, instead of\\nthe user's.\"), mdx(\"p\", null, \"You'll need to first get \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.cloudflare.com/ips\"\n  }), \"the list\"), \" of all the\\nIP addresses Cloudflare uses for proxy traffic, which will be used in the next\\nsteps.\"), mdx(\"h3\", {\n    \"id\": \"s3\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#s3\",\n    \"aria-label\": \"s3 permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"S3\"), mdx(\"p\", null, \"For S3, you can restrict traffic to only traffic from Cloudflare by creating a\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bucket policy\"), \". To do this, go to the Amazon S3 console, choose your bucket,\\nclick \\\"Permissions\\\", then click \\\"Bucket Policy\\\". You'll then be greeted by a\\ntext editor, where you can add a bucket policy.\"), mdx(\"p\", null, \"The following bucket policy allows the action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s3:GetObject\"), \"--aka HTTP GET\\nrequests--to all objects in your bucket, given that the source IP address is\\nwithin one of the addresses listed in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"aws:SourceIp\"), \". The IP addresses listed\\nare currently all the IP addresses Cloudflare uses.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json:title=bucket_policy.json\"\n  }), \"{\\n  \\\"Version\\\": \\\"2012-10-17\\\",\\n  \\\"Statement\\\": [\\n    {\\n      \\\"Sid\\\": \\\"PublicReadGetObject\\\",\\n      \\\"Effect\\\": \\\"Allow\\\",\\n      \\\"Principal\\\": \\\"*\\\",\\n      \\\"Action\\\": \\\"s3:GetObject\\\",\\n      \\\"Resource\\\": \\\"arn:aws:s3:::BUCKET_NAME/*\\\",\\n      \\\"Condition\\\": {\\n        \\\"IpAddress\\\": {\\n          \\\"aws:SourceIp\\\": [\\n            \\\"2400:cb00::/32\\\",\\n            \\\"2405:8100::/32\\\",\\n            \\\"2405:b500::/32\\\",\\n            \\\"2606:4700::/32\\\",\\n            \\\"2803:f800::/32\\\",\\n            \\\"2c0f:f248::/32\\\",\\n            \\\"2a06:98c0::/29\\\",\\n            \\\"103.21.244.0/22\\\",\\n            \\\"103.22.200.0/22\\\",\\n            \\\"103.31.4.0/22\\\",\\n            \\\"104.16.0.0/12\\\",\\n            \\\"108.162.192.0/18\\\",\\n            \\\"131.0.72.0/22\\\",\\n            \\\"141.101.64.0/18\\\",\\n            \\\"162.158.0.0/15\\\",\\n            \\\"172.64.0.0/13\\\",\\n            \\\"173.245.48.0/20\\\",\\n            \\\"188.114.96.0/20\\\",\\n            \\\"190.93.240.0/20\\\",\\n            \\\"197.234.240.0/22\\\",\\n            \\\"198.41.128.0/17\\\"\\n          ]\\n        }\\n      }\\n    }\\n  ]\\n}\\n\")), mdx(\"p\", null, \"Once you save the bucket policy, all objects will only be accessible through\\nCloudflare. For example, if I put an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.html\"), \" at the root of my bucket, and\\nattempt to load it by its default AWS S3 URL\\n(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"https://s3.amazonaws.com/BUCKET_NAME/index.html\"), \"), I'm greeted with\\n\\\"AccessDenied\\\":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-xml\"\n  }), \"<Error>\\n  <Code>AccessDenied</Code>\\n  <Message>Access Denied</Message>\\n  <RequestId>EBD7E77186227632</RequestId>\\n  <HostId>\\n    JhPjXJKGdWUbP14jkhti8RdkenxGyG8+zm1h9Cew/hOkiYIiXKpQ3uCA1OTJVO5wBcxwAvqZq/s=\\n  </HostId>\\n</Error>\\n\")), mdx(\"p\", null, \"However, after pointing Cloudflare to the bucket, I can succesfully access that\\nfile (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"https://CLOUDFLARE_URL/index.html\"), \"):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Hello world!\\n\")), mdx(\"h3\", {\n    \"id\": \"google-cloud-compute-engine\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#google-cloud-compute-engine\",\n    \"aria-label\": \"google cloud compute engine permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Google Cloud Compute Engine\"), mdx(\"p\", null, \"You can also restrict your Google Cloud Compute Engine instance to only accept traffic\\nfrom Cloudflare IP addresses. Go to the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://console.cloud.google.com/networking/firewalls/list\"\n  }), \"Firewall\\nrules\"), \" page in\\nGoogle Cloud Console for project. Then select \\\"Create Firewall Rule\\\". Give it a\\nname and description; I like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cloudflare-allow-http-https\"), \". Keep \\\"Direction\\\" as\\n\\\"Ingress\\\", since you're restricting inbound traffic. Set \\\"Action on match\\\" to\\n\\\"Allow\\\". \\\"Targets\\\" allows you to set this Firewall rule for all compute units in\\nyour account or just selected ones. Since I also have compute units under the\\nsame project that shouldn't receive HTTP traffic, I add a target tag to the\\nfirewall, and also add the same target tag to the compute instance to which I\\nwant to allow traffic.\"), mdx(\"p\", null, \"For \\\"Source filter\\\", keep it as \\\"IP ranges\\\", then add the list of Cloudflare's\\nsource IP ranges. Annoyingly, this apparently must be done one at a time. Also,\\nI got errors when trying to add Cloudflare's IPv6 addresses, so I only added its\\nIPv4 addresses and it appears to work fine. The IPv4 addresses are the ones of\\nthe form \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[0-255].[0-255].[0-255].[0-255]\"), \".\"), mdx(\"p\", null, \"For \\\"Protocols and ports\\\", choose \\\"Specified protocols and ports\\\", and set \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tcp\"), \"\\nto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"80,443\"), \", which are the ports used for HTTP and HTTPS traffic.\"), mdx(\"p\", null, \"Then click \\\"Create\\\" and wait for the rule to be created.\"), mdx(\"p\", null, \"If you added a \\\"Target tag\\\" in the firewall, don't forget to go back to the VM\\ninstance, choose \\\"Edit\\\", and add that tag under \\\"Network tags\\\".\"), mdx(\"p\", null, \"You should be able to test that the firewall is working correctly by attempting\\nto navigate to the instance's external IP address in your browser. It should\\ntimeout.\"), mdx(\"h2\", {\n    \"id\": \"cors\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#cors\",\n    \"aria-label\": \"cors permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"CORS\"), mdx(\"p\", null, \"From the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://support.cloudflare.com/hc/en-us/articles/200308847-Using-cross-origin-resource-sharing-CORS-with-Cloudflare#4vknA9IbgW57oiclaPv4QP\"\n  }), \"Cloudflare documentation\"), \", there are three options to make Cloudflare's cache see your updated CORS headers:\"), mdx(\"blockquote\", null, mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Change the filename or URL to bypass cache to instruct Cloudflare to retrieve the latest CORS headers.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use the single-file purge API to specify the appropriate CORS headers along with the purge request\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Update the resource\\u2019s last-modified time at your origin web server. Then, complete a full purge to retrieve the latest version of your assets including updated CORS headers\"))), mdx(\"p\", null, \"Each of these options is difficult. For the first, you need to change all your\\nfilenames, which can be a burden on S3. The second implies you need to purge\\nevery file individually through their API, which could take a while and be easy\\nto miss some files.\"), mdx(\"p\", null, \"The overall lesson here is to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"minimize CORS header changes\"), \". It's much easier\\nto set up the first time than to change. If you're constantly creating new\\ndomain names that you want to access your map data from, you might want to have\\na more open CORS configuration, so that you don't need to go through one of\\nthese steps on every new domain.\"), mdx(\"h3\", {\n    \"id\": \"aws-s3\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#aws-s3\",\n    \"aria-label\": \"aws s3 permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"AWS S3\"), mdx(\"p\", null, \"By default, a bucket's CORS configuration is empty. This means that only\\nrequests from the same domain will be accepted. You can test this with\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch(URL)\"), \" in the browser console. If you go to a different domain, say,\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"https://google.com\"), \", and then try:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"fetch(\\\"https://CLOUDFLARE_URL/index.html\\\");\\n\")), mdx(\"p\", null, \"you'll see an error message like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Access to fetch at 'https://CLOUDFLARE_URL/index.html' from origin\\n'https://www.google.com' has been blocked by CORS policy: No\\n'Access-Control-Allow-Origin' header is present on the requested resource. If an\\nopaque response serves your needs, set the request's mode to 'no-cors' to fetch\\nthe resource with CORS disabled.\\n\")), mdx(\"p\", null, \"while if you go to the same domain, say \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"https://CLOUDFLARE_URL/index.html\"), \", and\\nthen try the request again \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch('https://CLOUDFLARE_URL/index.html')\"), \", it'll\\ngo through because the request was coming from the same address.\"), mdx(\"p\", null, \"If you wanted to allow \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"every website\"), \" to load content from your bucket, you\\ncould add a CORS configuration like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-xml\"\n  }), \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<CORSConfiguration>\\n<CORSRule>\\n    <AllowedOrigin>*</AllowedOrigin>\\n    <AllowedMethod>GET</AllowedMethod>\\n    <AllowedMethod>HEAD</AllowedMethod>\\n    <MaxAgeSeconds>3000</MaxAgeSeconds>\\n    <AllowedHeader>*</AllowedHeader>\\n</CORSRule>\\n</CORSConfiguration>\\n\")), mdx(\"p\", null, \"I only want \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"selected websites\"), \" to be able to load my content, so I can instead\\nuse a CORS configuration like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-xml\"\n  }), \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<CORSConfiguration>\\n  <CORSRule>\\n    <AllowedOrigin>*kylebarron.dev</AllowedOrigin>\\n    <AllowedMethod>GET</AllowedMethod>\\n    <AllowedMethod>HEAD</AllowedMethod>\\n    <MaxAgeSeconds>3000</MaxAgeSeconds>\\n    <AllowedHeader>*</AllowedHeader>\\n  </CORSRule>\\n  <CORSRule>\\n    <AllowedOrigin>http://www.example2.com</AllowedOrigin>\\n    <AllowedMethod>PUT</AllowedMethod>\\n    <AllowedMethod>POST</AllowedMethod>\\n    <AllowedMethod>DELETE</AllowedMethod>\\n    <AllowedHeader>*</AllowedHeader>\\n  </CORSRule>\\n</CORSConfiguration>\\n\")), mdx(\"h3\", {\n    \"id\": \"update-cloudflares-cors-cache\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#update-cloudflares-cors-cache\",\n    \"aria-label\": \"update cloudflares cors cache permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"strong\", {\n    parentName: \"h3\"\n  }, \"Update Cloudflare's CORS cache\")), mdx(\"p\", null, \"If you've updated your CORS,\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"I self host map tiles and other large assets for use by my own projects, but in\ngeneral I don't want to host map data for anyone on the…","timeToRead":4,"banner":null}},"pageContext":{"slug":"/protect-self-hosted-assets-with-firewalls-and-cors","formatString":"MMMM Do, YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}