{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/blog/reading-stata-files-with-python","result":{"data":{"post":{"__typename":"MdxPost","id":"fe3f8fb9-faf0-509a-ae71-b6551512134a","slug":"/blog/reading-stata-files-with-python","title":"Reading Stata files with Python","date":"January 8th, 2018","tags":null,"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Reading Stata files with Python\",\n  \"date\": \"2018-01-08T00:00:00.000Z\",\n  \"slug\": \"/blog/reading-stata-files-with-python\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Stata is fine for the small stuff, but Python is way better for anything\\nintensive. However, you'll often have data in Stata's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".dta\"), \" format that you\\nneed to read. This post will detail the nice features available in Python's\\nStata import.\"), mdx(\"p\", null, \"We'll use the 1978 Automobile Data that comes with Stata. First export this data into a file in your working directory:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-stata\"\n  }), \"sysuse auto\\nsave \\\"auto.dta\\\", replace\\n\")), mdx(\"p\", null, \"Now open up Python. First import Pandas, the module in Python used to work with rectangular data frames.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import pandas as pd\\n\")), mdx(\"p\", null, \"The most straightforward way to import a Stata file is a single line:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"auto = pd.read_stata('auto.dta')\\n\")), mdx(\"p\", null, \"This is really simple, and is fine for small files, but with larger files, you often need to finesse your data import.\\nImagine you have a 100GB Stata file. For most computers, that's too big to import into memory.\"), mdx(\"p\", null, \"First we need to create an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"iterator\"), \", which reads the metadata attached to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".dta\"), \" file, but importantly doesn't read the data itself yet.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"itr = pd.read_stata('auto.dta', iterator = True)\\n\")), mdx(\"p\", null, \"Now it's possible to read in just a chunk of the data at a time.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"auto = itr.get_chunk(5)\\n\")), mdx(\"p\", null, \"You can also easily loop over the data like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"itr = pd.read_stata('auto.dta', iterator = True, chunksize = 10)\\nfor df in itr:\\n    # Program operating on 10 rows of the dataset at a time\\n\\n\")), mdx(\"p\", null, \"Now without importing the file, we can get the data label, number of observations, number of variables, and the timestamp at which the data were last saved.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"itr.data_label\\nitr.nobs\\nitr.nvar\\nitr.time_stamp\\n\")), mdx(\"p\", null, \"If we want to see the names and labels of the variables, we can use\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"itr.varlist\\nitr.variable_labels()\\n\")), mdx(\"p\", null, \"Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itr.variable_labels()\"), \" returns a dictionary where the keys of the dictionary are the variable names and the values of the dictionary are the variable labels. So we can access the labels with something like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"labels = itr.variable_labels()\\n# Gets the label of `mpg`\\nlabels['mpg']\\n# Gets all keys\\nlabels.keys()\\n# Gets all values\\nlabels.values()\\n\")), mdx(\"p\", null, \"If you're working with a large dataset that might run up against memory constraints, you might want to keep in mind exactly how much memory the imported data will take up.\"), mdx(\"p\", null, \"You can get a list of the number of bytes each column takes up with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"col_sizes\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"itr.col_sizes\\n\")), mdx(\"p\", null, \"So in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"auto.dta\"), \", the first column takes up 18 bytes for each row, while the rest of the columns take up between 1 and 4 bytes.\"), mdx(\"p\", null, \"Lets get a better idea of what data types these columns are.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"itr.dtyplist\\nitr.fmtlist\\n\")), mdx(\"p\", null, \"The former shows you the data types that will be used in Python upon import and the latter shows the display formats the data had used in Stata (see \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.stata.com/help.cgi?format\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"help format\")), \").\"), mdx(\"p\", null, \"From \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itr.dtyplist\"), \", we can see that the first column is a string of length 18, while the rest are types \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"numpy.int8\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"numpy.int16\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"numpy.float32\"), \". These data types come from \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.numpy.org/\"\n  }), \"Numpy\"), \", a scientific library that Pandas is based upon, and correspond to Stata's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"byte\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"float\"), \", respectively (see Stata's \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.stata.com/help.cgi?datatypes\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"help data types\")), \").\"), mdx(\"p\", null, \"The size of the data in memory is almost exactly the number of rows times the sum of the number of bytes needed for each row. I.e. if the number of rows is\"), mdx(TeX, {\n    math: \"N\",\n    mdxType: \"TeX\"\n  }), mdx(\"p\", null, \"and the number of bytes each column uses is\"), mdx(TeX, {\n    math: \"B_{col}\",\n    mdxType: \"TeX\"\n  }), mdx(\"p\", null, \"then the total memory use of the dataset is\"), mdx(TeX, {\n    math: \"N * \\\\sum_{col} B_{col}\",\n    mdxType: \"TeX\"\n  }), mdx(\"p\", null, \"This can be helpful with understanding how many rows of a file to import at once. Let's say you want to not use more than 1GB of memory at once. If you want to import all columns of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"auto.dta\"), \", each row takes up \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum(itr.col_sizes)\"), \" = 43 bytes. So the number of rows you can import at a time is\"), mdx(TeX, {\n    math: \"1024 MB * \\\\frac{1024 KB}{1 MB} * \\\\frac{1024 B}{1 KB} * \\\\frac{1 \\\\text{ row}}{43 B} \\\\approx 25 \\\\text{ million rows}\",\n    block: true,\n    mdxType: \"TeX\"\n  }), mdx(\"p\", null, \"Obviously with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"auto.dta\"), \" dataset we don't need to add restrictions on rows or columns, but in datasets with columns -- especially those with many string columns -- you might not be able to read in your whole dataset at once.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Stata is fine for the small stuff, but Python is way better for anything\nintensive. However, you'll often have data in Stata's  .dta  format…","timeToRead":2,"banner":null}},"pageContext":{"slug":"/blog/reading-stata-files-with-python","formatString":"MMMM Do, YYYY"}}}