{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/self-hosted-vector-topographic-maps-with-open-map-tiles","result":{"data":{"post":{"__typename":"MdxPost","id":"8b158dc2-bbc7-5942-9fde-9a26e2b6d0ad","slug":"/self-hosted-vector-topographic-maps-with-open-map-tiles","title":"Self hosted vector topographic maps with OpenMapTiles","date":"January 1st, 2017","tags":null,"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"post\",\n  \"title\": \"Self hosted vector topographic maps with OpenMapTiles\",\n  \"date\": \"2016-12-31 21:46:42 -0500\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"self-hosted-topographic-vector-maps-with-openmaptiles\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#self-hosted-topographic-vector-maps-with-openmaptiles\",\n    \"aria-label\": \"self hosted topographic vector maps with openmaptiles permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Self hosted topographic vector maps with OpenMapTiles\"), mdx(\"p\", null, \"There are two types of map tiles: raster and vector. Akin to PNG vs SVG images, vector map tiles usually have smaller file sizes and don't have pixelation as you zoom.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://switch2osm.org/\"\n  }), \"Switch2OSM\"), \" has some helpful notes for using OSM data, but it only mentions raster tiles, and it doesn't mention hosting maps on a static host such as S3.\"), mdx(\"p\", null, \"If you need constantly updated maps, S3 might not be for you, but for my use case, I'm fine with updating the OSM map tiles a couple times a year.\"), mdx(\"p\", null, \"Vector tile benefits:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"smaller file sizes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"completely static backend; all rendering happens on the client\"), mdx(\"li\", {\n    parentName: \"ul\"\n  })), mdx(\"h3\", {\n    \"id\": \"overview\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#overview\",\n    \"aria-label\": \"overview permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Overview\"), mdx(\"p\", null, \"For this example, I'll only generate map tiles for the US state of New Hampshire,\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Set up AWS S3 to serve map tiles. Note that it's ok if a domain name you want has already been taken as a bucket, because you could host the website itself somewhere else, and just host the map tiles on S3.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Generate map layers\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use OpenMapTiles to generate vector map tiles (TODO: how is the OpenMapTiles schema different from the Mapbox schema? Why can't they just be interchanged?)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Generate terrain-rgb compliant tiles for client-side hillshading\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Generate contour lines from USGS contours\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Upload the map data to S3\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Style your map\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Put it on a web map with Mapbox GL JS\")), mdx(\"h3\", {\n    \"id\": \"openmaptiles\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#openmaptiles\",\n    \"aria-label\": \"openmaptiles permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"OpenMapTiles\"), mdx(\"p\", null, \"The \", \"[OpenMapTiles][openmaptiles]\", \" project provides ready-to-use scripts to create\\nmap tiles for a geographic area. Hard to create global tiles, but for a portion\\nof the US, it works well on a 2019 8-core MacbookPro.\"), mdx(\"p\", null, \"The project works by encoding OSM vector data into portions of the tiles. Since\\nthe minute details of roads and trails are unnecessary when zoomed out, features\\nare simplified at low zooms, and some features aren't included until a specific\\nzoom is met.\"), mdx(\"p\", null, \"I found that for a topographic map, OpenMapTiles doesn't include trails and\\nstreams in the vector tiles at my desired zoom level, so I've forked the project\\nand set streams to appear at zoom XX and trails to appear at zoom XX.\"), mdx(\"p\", null, \"If you don't want these changes, just clone the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"openmaptiles/openmaptiles\"), \" repo instead.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"git clone https://github.com/nst-guide/openmaptiles\\ncd openmaptiles\\n\")), mdx(\"p\", null, \"Then download the docker images:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"docker-compose pull\\n\")), mdx(\"p\", null, \"Edit \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QUICKSTART_MAX_ZOOM\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" to your desired highest zoom level. I've\\nfound that this is only correctly set when the extract is downloaded again from\\nGeofabrik. If the extract already exists, this doesn't appear to get set.\"), mdx(\"p\", null, \"It's usually a good idea to set a small zoom at first to make sure that\\neverything is working, and only then increase the zoom to a higher level for\\nproduction. Zoom 14 or 15 is usually a good max level.\"), mdx(\"p\", null, \"Then run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"./quickstart.sh {region}\"), \" for any given Geofabrik region. This\\ndownloads the OSM extract from Geofabrik, imports the data into a Postgres\\ndatabase, and then writes output to an Mbtiles file according to the\\nOpenMapTiles schema. For this example with New Hampshire, run:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"./quickstart.sh new-hampshire\\n\")), mdx(\"p\", null, \"Notes when merging multiple Geofabrik regions:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"any Mbtiles file in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data/\"), \" directory is removed each time \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"./quickstart.sh\"), \" is run. So if you want to merge two states, you should do:\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  (TODO I forget the name of the output mbtiles file)\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"./quickstart.sh new-hampshire\\nmv data/*.mbtiles ./\\n./quickstart.sh vermont\\ntile-join combined.mbtiles data/*.mbtiles *.mbtiles\\n\")))), mdx(\"p\", null, \"[openmaptiles]\"), mdx(\"h3\", {\n    \"id\": \"contours\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#contours\",\n    \"aria-label\": \"contours permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Contours\"), mdx(\"p\", null, \"Contour lines (isobands) are essential for a topographic map. They show equal\\nheights on the land. The US Geological Survey releases \", \"[1x1 degree 40' contour\\nline data][contours]\", \" generated from their 1/3 arc-second seamless DEM. While\\nit's possible to generate contours yourself from a Digital Elevation Model,\\nusing the USGS's contours are easy because they're already in vector format. In\\norder to integrate this data with OpenMapTiles, I need to cut the contour lines\\ninto vector tiles, and then add them as a separate source in my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"style.json\"), \"\\nfile.\"), mdx(\"p\", null, \"I've written scripts to query the USGS API and download contours for a given bounding box.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"git clone https://github.com/nst-guide/contours\\ncd contours\\npip install click requests\\n\")), mdx(\"p\", null, \"This also has dependencies on GDAL and\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/mapbox/tippecanoe\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"tippecanoe\")), \". I find that the easiest\\nway of installing GDAL and tippecanoe is through Conda:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"conda create -n contours python gdal tippecanoe -c conda-forge\\nsource activate contours\\npip install click requests\\n\")), mdx(\"h4\", {\n    \"id\": \"download-files\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#download-files\",\n    \"aria-label\": \"download files permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Download files\"), mdx(\"p\", null, \"I generally use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://boundingbox.klokantech.com/\"\n  }), \"https://boundingbox.klokantech.com/\"), \" to visually create\\nbounding boxes. This is a good one for New Hampshire:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"python download.py --bbox=\\\"-72.5623, 42.6938, -70.6603, 45.3534\\\"\\nbash to_geojson.sh\\ntippecanoe \\\\\\n    -Z11 \\\\\\n    -zg \\\\\\n    -P \\\\\\n    --extend-zooms-if-still-dropping \\\\\\n    -y FCode -y ContourElevation \\\\\\n    -l Elev_Contour \\\\\\n    -o contours.mbtiles \\\\\\n    data/geojson/*.geojson\\n\")), mdx(\"p\", null, \"I use these tippecanoe options:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-Z11\"), \": Set the minimum zoom to 11. Tippecanoe won't create any overview tiles.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-zg\"), \": Let Tippecanoe guess the maximum zoom level. It seems from testing that it selects \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"11\"), \", i.e. that 11 is high enough to represent the contours\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-P\"), \": run in parallel. If the GeoJSON files are not line-delimited, won't actually run in parallel.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--extend-zooms-if-still-dropping\"), \": Not sure if this actually does anything since I'm not using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--drop-densest-as-needed\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-y\"), \": only keep the provided attributes in the MVT. I think the only metadata needed for styling is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FCode\"), \", which determines whether it's a multiple of 200' and should be styled darker, and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ContourElevation\"), \", which stores the elevation itself. I haven't checked if you can do modular arithmetic on the fly in the Mapbox style specification, but if you can then you could leave out \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FCode\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-l\"), \": combine all files into a single layer named \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Elev_Contour\"), \". Otherwise, it would create a different layer in the vector tiles for each provided file name\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-o\"), \": output file name. If you want a directory of vector tiles instead of a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".mbtiles\"), \" file, use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-e\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"data/geojson/*.geojson\"), \": path to input data\")), mdx(\"h3\", {\n    \"id\": \"hillshading\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#hillshading\",\n    \"aria-label\": \"hillshading permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Hillshading\"), mdx(\"p\", null, \"Hillshading is essential\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"git clone https://github.com/nst-guide/hillshade\\ncd hillshade\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"python download.py --bbox=\\\"-72.5623, 42.6938, -70.6603, 45.3534\\\" --high_res\\nbash unzip.sh --high_res\\ngdalbuildvrt -vrtnodata -9999 data/dem_hr_9999.vrt data/unzipped_hr/*.img\\ngdalwarp -r cubicspline -s_srs EPSG:4269 -t_srs EPSG:3857 -dstnodata 0 -co COMPRESS=DEFLATE data/dem_hr_9999.vrt data/dem_hr_9999_epsg3857.vrt\\nrio rgbify -b -10000 -i 0.1 --min-z 6 --max-z 13 -j 15 --format webp data/dem_hr_9999_epsg3857.vrt data/terrain_webp.mbtiles\\nrio rgbify -b -10000 -i 0.1 --min-z 6 --max-z 13 -j 15 --format png data/dem_hr_9999_epsg3857.vrt data/terrain_png.mbtiles\\nmb-util data/terrain_webp.mbtiles data/terrain_webp\\nmb-util data/terrain_png.mbtiles data/terrain_png\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Self hosted topographic vector maps with OpenMapTiles There are two types of map tiles: raster and vector. Akin to PNG vs SVG images, vectorâ€¦","timeToRead":3,"banner":null}},"pageContext":{"slug":"/self-hosted-vector-topographic-maps-with-open-map-tiles","formatString":"MMMM Do, YYYY"}}}