---
title: Projects
slug: "/projects"
---

import GithubLink from "../../../src/components/GithubLink";

I love to explore and build new things. I've recently been focused on projects
to support reproducible web-based mapping. The source for nearly all my projects
is available at [Github](https://github.com/kylebarron).

## GeoPolars

<GithubLink
  languages={["rust", "py", "js"]}
  href="https://github.com/kylebarron/pyflatbush"
/>

GeoPolars extends the [Polars](https://github.com/pola-rs/polars) DataFrame library for use with geospatial data.

## parquet-wasm

<GithubLink
  languages={["rust"]}
  href="https://github.com/kylebarron/pyflatbush"
/>

Rust-based WebAssembly bindings to read and write Apache Parquet data

## pyflatbush

<GithubLink
  languages={["cython", "py"]}
  href="https://github.com/kylebarron/pyflatbush"
/>

A Cython port of [Flatbush](https://github.com/mourner/flatbush) for fast, static 2D spatial indexing.

## suncalc-py

<GithubLink
  languages={["py"]}
  href="https://github.com/kylebarron/suncalc-py"
/>

A fast, vectorized Python implementation of [`suncalc.js`](https://github.com/mourner/suncalc) for calculating sun position and sunlight phases (times for sunrise, sunset, dusk, etc.) for the given location and time.

## pymartini

<GithubLink
  languages={["cython", "py"]}
  href="https://github.com/kylebarron/pymartini"
/>

A Cython port of [Martini](https://github.com/mapbox/martini) for fast RTIN
terrain mesh generation, 2-3x faster than Martini in Node.

This was my first time using Cython and I was thrilled with its
ease of use and performance. Upon first porting the original JavaScript Martini
code to pure Python, it was taking around 5 seconds to generate one tile. After
converting to Cython, it's within 50 milliseconds.

## quantized-mesh-encoder

<div>
  <GithubLink
    languages={["py"]}
    href="https://github.com/kylebarron/quantized-mesh-encoder"
  />
</div>


A fast Python [Quantized Mesh](https://github.com/CesiumGS/quantized-mesh)
encoder. Encodes a mesh with 100k coordinates and 180k triangles in 20ms.

With judicious use of vectorized Numpy functions, I was able to achieve speeds
of at least 100x faster than [an existing Python
library](https://github.com/loicgasser/quantized-mesh-tile).

<h2>
  <a href="https://kylebarron.dev/naip-cogeo-mosaic/" target="blank">
    naip-cogeo-mosaic
  </a>
</h2>
<div>
  <GithubLink
    languages={["py"]}
    href="https://github.com/kylebarron/naip-cogeo-mosaic"
  />
</div>

Serverless high-resolution NAIP map tiles from Cloud-Optimized GeoTIFFs for the lower 48 U.S. states.

## deck.gl-raster

<GithubLink
  languages={["js", "glsl"]}
  href="https://github.com/kylebarron/deck.gl-raster"
/>

deck.gl layers and WebGL modules for client-side satellite imagery analysis.

## usgs-topo-tiler & usgs-topo-mosaic

<div>
  <GithubLink
    languages={["py"]}
    href="https://github.com/kylebarron/usgs-topo-tiler"
    linkText="Source: usgs-topo-tiler"
  />
</div>
<div>
  <GithubLink
    languages={["py"]}
    href="https://github.com/kylebarron/usgs-topo-mosaic"
    linkText="Source: usgs-topo-mosaic"
  />
</div>


`usgs-topo-tiler` is a Python package to read Web Mercator map tiles from USGS
Historical Topographic Maps. `usgs-topo-mosaic` is a fork of
[cogeo-mosaic-tiler][cogeo-mosaic-tiler] to serve USGS Historical Topographic
map tiles on demand. Together, they enable serving map tiles on demand from the
USGS's [public collection][usgs_htmc] of 181,000 historical topographic maps.

[cogeo-mosaic-tiler]: https://github.com/developmentseed/cogeo-mosaic-tiler
[usgs_htmc]: https://www.usgs.gov/core-science-systems/ngp/topo-maps/historical-topographic-map-collection?qt-science_support_page_related_con=0

<h2>
  <a href="https://all-transit.com" target="blank">
    All Transit
  </a>
</h2>
<div>
  <GithubLink
    languages={["js", "bash", "py"]}
    href="https://github.com/kylebarron/all-transit"
  />
</div>

A visualization of all public transit in the world (or at least what exists in
the [Transitland](https://transit.land) database). Zoom into a city in the U.S.
to see an animation of transit vehicles moving along their routes.

I use Python, [`jq`](https://stedolan.github.io/jq/), and `sqlite` to download
and analyze the source data. I use Gatsby and React for the website structure. I
use React Map GL/Mapbox GL JS and Deck.gl for the map rendering; the former for
the route geometries and the latter for the schedule animation. I use `d3` to
generate a high-resolution static image of transit in the continental U.S.

<h2>
  <a href="https://nst.guide" target="_blank" rel="noopener noreferrer">
    National Scenic Trails Guide
  </a>
</h2>
<div>
  <div>
    <GithubLink
      languages={["js"]}
      href="https://github.com/nst-guide/web"
      linkText="Source: Website"
    />
  </div>
  {/* <div>
    <GithubLink
      languages={["js"]}
      href="https://github.com/nst-guide/mobile"
      linkText="Source: Mobile App"
    />{" "}
    (In progress)
  </div> */}
  <div>
    <GithubLink
      languages={["py"]}
      href="https://github.com/nst-guide/data"
      linkText="Source: Data Generation"
    />
  </div>
</div>

An open-source project for exploring and navigating U.S. National Scenic Trails,
starting with the Pacific Crest Trail.

The [website](https://nst.guide) is designed to bring together most information
hikers want: data overlays exist for land management boundaries, current and
historical wildfires, public transit options near the trail or trail towns,
current air quality, photography, and Wikipedia articles. All units, including
peak elevations and contour lines, can be switched between Imperial and Metric.

<!-- The mobile app (in progress) will give hikers a free option for navigation while
hiking the trail. It's built with React Native and
[`react-native-mapbox-gl`](https://github.com/react-native-mapbox-gl/maps), to
cover both platforms as efficiently as possible while giving me more experience
with React. -->

Essentially all data generation is automated, to allow for the possibility of
expanding to other National Scenic Trails in the future.

<h2>
  <a
    href="https://nst-guide.github.io/osm-liberty-topo"
    target="_blank"
    rel="noopener noreferrer"
  >
    OSM Liberty Topo
  </a>
</h2>
<GithubLink href="https://github.com/nst-guide/osm-liberty-topo" />

A free topographic Mapbox GL basemap style with complete liberty to use and self
host. This is a fork of [OSM Liberty](https://github.com/maputnik/osm-liberty)
and combines vector tiles in the schema of OpenMapTiles with contour lines and
hillshading to create a beautiful topographic vector map.

## OSM Liberty

<GithubLink href="https://github.com/maputnik/osm-liberty" />

OSM Liberty is one of the best free Mapbox GL basemap styles for general use. I
contributed styling for river names and glacier land cover.

## nst-guide/terrain

<GithubLink
  languages={["py", "bash"]}
  href="https://github.com/nst-guide/terrain"
/>

Scripts to generate contours, hillshade, [Terrain
RGB](https://docs.mapbox.com/help/troubleshooting/access-elevation-data/#mapbox-terrain-rgb),
and slope-angle shading tiles from Digital Elevation Model (DEM) data.

<h2>
  <a
    href="https://nst-guide.github.io/naip"
    target="_blank"
    rel="noopener noreferrer"
  >
    nst-guide/naip
  </a>
</h2>
<GithubLink languages={["py"]} href="https://github.com/nst-guide/naip" />

Scripts to generate high-resolution aerial imagery tiles from USDA National
Agriculture Imagery Program (NAIP) data.

<h2>
  <a
    href="https://nst-guide.github.io/fstopo"
    target="_blank"
    rel="noopener noreferrer"
  >
    nst-guide/fstopo
  </a>
</h2>
<GithubLink languages={["py"]} href="https://github.com/nst-guide/fstopo" />

Scripts to generate map tiles from US Forest Service Topo quadrangle maps.

<h2>
  <a
    href="https://nst-guide.github.io/contours"
    target="_blank"
    rel="noopener noreferrer"
  >
    nst-guide/contours
  </a>
</h2>
<GithubLink
  languages={["py", "bash"]}
  href="https://github.com/nst-guide/contours"
/>

Scripts to generate vector tile contours from USGS contour data.

## snap-to-tin

<GithubLink
  languages={["ts"]}
  href="https://github.com/kylebarron/snap-to-tin"
/>

Snap vector features to the faces of a triangulated irregular network (TIN)

## `demquery`

<GithubLink languages={["py"]} href="https://github.com/kylebarron/demquery" />

Python library and command line interface to quickly and easily query elevation
values on Digital Elevation Models. The command line interface can add
elevations to a provided GeoJSON FeatureCollection.

## `keplergl_cli`

<GithubLink
  languages={["py"]}
  href="https://github.com/kylebarron/keplergl_cli"
/>

Python library and command line interface to quickly and interactively visualize
geospatial data with [Kepler.gl](https://kepler.gl/). Since I work with GIS data
in Python, I use this whenever I need to see my data on a map.

# Jupyter

## Stata Jupyter Kernel

<GithubLink
  languages={["py"]}
  href="https://github.com/kylebarron/stata_kernel"
/>

Connects the [Stata](https://stata.com) statistical package to the
[Jupyter](https://jupyter.org/) ecosystem, enabling researchers to use a modern
data science toolkit with Stata.

Jupyter Notebooks permit sharing of code and results together, with simple
reproducible modifications in a web-based computational environment. Alternative
front-ends like [Hydrogen](https://github.com/nteract/hydrogen) allow for rich
HTML output even from computations on a remote server.

As of February 2020, it has been downloaded [nearly 90,000 times](https://pepy.tech/project/stata-kernel).

## Hydrogen

<GithubLink languages={["js"]} href="https://github.com/nteract/hydrogen" />

The Hydrogen project is a front-end for the [Jupyter](https://jupyter.org)
project, enabling interactive coding and rich output formats inside the Atom
text editor. I [contributed
code](https://github.com/nteract/hydrogen/commits?author=kylebarron) that
allowed Jupyter Notebook files to be imported and exported as regular Python
files.

# Stata

While working as an economics research assistant, I built a number of
open-source tools that interface with the [Stata statistical
package](https://stata.com) to improve research reproducibility and increase
productivity.

## `stata-exec`

<GithubLink
  languages={["js"]}
  href="https://github.com/kylebarron/stata-exec"
/>

Send code to the Stata window from the Atom text editor. This is a more
primitive version of running Stata code from Atom than the Jupyter kernel above.

## `language-stata`

<GithubLink
  languages={["py"]}
  href="https://github.com/kylebarron/language-stata"
/>

Syntax highlighting for Stata for the [Atom text editor](https://atom.io).

## `stataParquet`

<GithubLink
  languages={["java"]}
  href="https://github.com/kylebarron/stataParquet"
/>

A prototype Java implementation of reading [Parquet
files](https://parquet.apache.org/) into Stata. My first Java project, I was
able to successfully read Parquet files into Stata's memory, but it ended up
being less performant than my friend Mauricio Caceres' [C++
implementation](https://github.com/mcaceresb/stata-parquet).

# Miscellaneous

## `medicare-documentation`

<GithubLink
  languages={["py"]}
  href="https://github.com/kylebarron/medicare-documentation/"
/>

While working with Medicare data, I was frustrated with the fragmented state of public documentation regarding the data I was working with.

I
[scraped](https://github.com/kylebarron/medicare-documentation/blob/master/code/02parse.py)
the [ResDAC documentation website](https://www.resdac.org/) and joined it with
[public NBER documentation](https://data.nber.org/medicare/) to create my own
beautiful, responsive [documentation
website](https://kylebarron.dev/medicare-documentation) to help me search
documentation faster. I used [MkDocs](https://www.mkdocs.org/) as the static
site generator and [Material for
MkDocs](https://squidfunk.github.io/mkdocs-material/) as the theming.

# Meta

<h2>
  <a href="https://kylebarron.dev" target="_blank" rel="noopener noreferrer">
    kylebarron.dev
  </a>
</h2>
<GithubLink
  languages={["js"]}
  href="https://github.com/kylebarron/kylebarron.github.io"
/>

This website is built with [GatsbyJS](https://www.gatsbyjs.org/), starting from
the
[`gatsby-starter-minimal-blog`](https://www.gatsbyjs.org/starters/LekoArts/gatsby-starter-minimal-blog/)
template.
