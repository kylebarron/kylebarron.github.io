"use strict";(self.webpackChunkkylebarron_github_io=self.webpackChunkkylebarron_github_io||[]).push([[396],{454:function(e,t,a){function n(e){if(null==e)throw new TypeError("Cannot destructure "+e)}a.d(t,{A:function(){return n}})},1173:function(e,t,a){a.d(t,{p:function(){return p},A:function(){return d}});var n=a(454),r=a(6540),o=a(9894),l=a(6835),i=a(9943),s=a(7715),c=a(7169);var h=e=>{let{post:t}=e;return null};const m=["16px","8px","4px"].map(e=>"rgba(0, 0, 0, 0.1) 0px "+e+" "+e+" 0px");var u=e=>{let{data:{post:t},children:a}=e;return(0,o.Y)(i.A,null,(0,o.Y)(l.DZ,{as:"h1",variant:"styles.h1"},t.title),(0,o.Y)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,o.Y)("time",null,t.date),t.tags&&(0,o.Y)(r.Fragment,null," — ",(0,o.Y)(s.A,{tags:t.tags})),t.timeToRead&&" — ",t.timeToRead&&(0,o.Y)("span",null,t.timeToRead," min read")),(0,o.Y)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:m.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},a),(0,o.Y)(h,{post:t}))};const p=e=>{var t,a,n;let{data:{post:r}}=e;return(0,o.Y)(c.A,{title:r.title,description:r.description?r.description:r.excerpt,image:r.banner?null===(t=r.banner)||void 0===t||null===(a=t.childImageSharp)||void 0===a||null===(n=a.resize)||void 0===n?void 0:n.src:void 0,pathname:r.slug,canonicalUrl:r.canonicalUrl})};function d(e){let t=Object.assign({},((0,n.A)(e),e));return r.createElement(u,t)}},6136:function(e,t,a){a.r(t),a.d(t,{Head:function(){return i.p},default:function(){return s}});var n=a(6540),r=a(8453);function o(e){const t=Object.assign({p:"p",a:"a",code:"code",em:"em",h2:"h2",span:"span",blockquote:"blockquote",h3:"h3",ul:"ul",li:"li",strong:"strong",h4:"h4"},(0,r.RP)(),e.components);return n.createElement(n.Fragment,null,n.createElement(t.p,null,"JavaScript is missing a battle-tested geometry engine that's performant at scale."),"\n",n.createElement(t.p,null,"Six months ago, Tom MacWright started a stub repository ",n.createElement(t.a,{href:"https://github.com/tmcw/geos-wasm"},n.createElement(t.code,null,"tmcw/geos-wasm"))," on compiling ",n.createElement(t.a,{href:"https://github.com/libgeos/geos"},"GEOS")," to WebAssembly (Wasm) and exposing it as a library for JavaScript. On Tuesday, Christoph Pahmeyer ",n.createElement(t.a,{href:"https://github.com/tmcw/geos-wasm/issues/2"},"created an issue"),' (enticingly titled "',n.createElement(t.em,null,n.createElement(t.code,null,"geos-wasm")," - Is it worth the effort?"),'") and mentioned that he created a new repo ',n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm"},n.createElement(t.code,null,"chrispahm/geos-wasm"))," with a ",n.createElement(t.a,{href:"https://chrispahm.github.io/geos-wasm/"},"full working demo")," of GEOS' buffer function (check it out! It's cool!)."),"\n",n.createElement(t.p,null,"That ",n.createElement(t.a,{href:"https://xkcd.com/356/"},"nerdsniped")," me, and here we are with a blog post! I'll start with why\nI'm a proponent of WebAssembly and then consider what bringing GEOS or something like it to the web\nwould look like."),"\n",n.createElement(t.h2,{id:"why-not-turf-jsts",style:{position:"relative"}},n.createElement(t.a,{href:"#why-not-turf-jsts","aria-label":"why not turf jsts permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Why not Turf? JSTS?"),"\n",n.createElement(t.p,null,"In Tom's repo he ",n.createElement(t.a,{href:"https://github.com/tmcw/geos-wasm/blob/07e6858a00d83b2ee78daaf5467c6e1e376aa966/README.md"},"wrote down some thoughts"),":"),"\n",n.createElement(t.blockquote,null,"\n",n.createElement(t.p,null,"I don't think WebAssembly will constitute a big performance advantage for geographical operations. However, what I do want is battle-tested geometry operations. I love Turf, and continue to contribute to Turf, but a lot of Turf's geometry algorithms are implemented from scratch and aren't nearly as robust as GEOS."),"\n",n.createElement(t.p,null,"Then Turf uses JSTS for a few of its operations. JSTS - JavaScript port of JTS, which is a port of GEOS - has gotten a lot better. Maybe JSTS is the real best option: it gives roughly the code of GEOS, albeit removed two steps from the original, but doesn't have the full serialization cost of a WASM library."),"\n",n.createElement(t.p,null,"That said, JSTS is large - we've been trying to remove it from Turf for years and years, and it's not exactly the same set of bugs as GEOS. If I have bugs, I want all of the GEOS things to have bugs! And the roaring success of, say, Shapely, indicates that GEOS's level of bugs is pretty tolerable."),"\n"),"\n",n.createElement(t.h3,{id:"porting-a-complex-library-is-really-hard",style:{position:"relative"}},n.createElement(t.a,{href:"#porting-a-complex-library-is-really-hard","aria-label":"porting a complex library is really hard permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),n.createElement(t.em,null,"Porting a complex library is really hard!")),"\n",n.createElement(t.p,null,"This is something I learned from the ",n.createElement(t.a,{href:"https://parquet.apache.org/"},"Apache Parquet")," ecosystem.\nParquet is an incredibly complex file format with scores of encodings, compressions, and types, including\nnested types. Pure-JavaScript implementations have been attempted over the years\n(",n.createElement(t.a,{href:"https://github.com/ironSource/parquetjs"},"1"),", ",n.createElement(t.a,{href:"https://github.com/kbajalc/parquets"},"2"),"), but all\nhave been abandoned. It's no surprise either that endless subtle bugs requiring a\ndeep understanding of the underlying data format would make the work brutal and lead to project\nburnout. Writing a stable JS implementation would be a massive investment."),"\n",n.createElement(t.p,null,"It's my belief that for any project beyond a certain complexity, there should only be three core implementations:"),"\n",n.createElement(t.ul,null,"\n",n.createElement(t.li,null,"One in C/C++ because C/C++ is today's de-facto performance-critical language, and it can bind to almost any other language."),"\n",n.createElement(t.li,null,"One in Rust because removing memory errors brings so much potential and Rust's ergonomics bring impressive development velocity to low-level code. I believe it's ",n.createElement(t.em,null,"tomorrow's")," performance-critical language."),"\n",n.createElement(t.li,null,"One in Java because the Java Virtual Machine makes it hard to interface with external C libraries (and it's ",n.createElement(t.em,null,"yesterday's")," performance-critical language?)."),"\n"),"\n",n.createElement(t.h3,{id:"in-high-level-languages-prefer-bindings",style:{position:"relative"}},n.createElement(t.a,{href:"#in-high-level-languages-prefer-bindings","aria-label":"in high level languages prefer bindings permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"In high-level languages, prefer bindings"),"\n","\n",n.createElement(t.p,null,"For every other language and environment, the code should be a ",n.createElement(t.em,null,"binding")," to a core library because\nit takes such a huge investment to reach the stability of a core library. These other\nimplementations should choose one of the above and ",n.createElement(t.em,null,"link")," to it for the core algorithms rather than\nreimplement the entire source in the target language."),"\n",n.createElement(t.p,null,"Keeping with the Parquet analogy above, there's a ",n.createElement(t.a,{href:"https://github.com/apache/arrow/tree/main/cpp/src/parquet"},"core implementation in C++"),", ",n.createElement(t.a,{href:"https://github.com/apache/parquet-mr"},"one in Java"),", and ",n.createElement(t.a,{href:"https://github.com/apache/arrow-rs/tree/master/parquet"},"another in Rust"),". [^1] But virtually every other stable Parquet library is a binding to one of those. The Python and R Parquet implementations are bindings to the C++ one; my ",n.createElement(t.a,{href:"https://github.com/kylebarron/parquet-wasm"},"WebAssembly Parquet implementation")," uses the Rust one. [^2] A ",n.createElement(t.a,{href:"https://github.com/mjakubowski84/parquet4s"},"Scala Parquet library")," appears ",n.createElement(t.a,{href:"https://github.com/mjakubowski84/parquet4s/blob/f41ff6d4203e039a0e52c7d0d5648e24ece37706/build.sbt#L91-L93"},"to use")," the Java implementation."),"\n",n.createElement(t.p,null,"Additionally, by having fewer core implementations, it's possible to focus energy on solving bugs in those, where previously efforts might have been spread more thin."),"\n",n.createElement(t.p,null,"[^1]: Well, actually there are ",n.createElement(t.a,{href:"https://github.com/jorgecarleitao/parquet2"},n.createElement(t.em,null,"two")," Rust implementations")," for technical reasons, but they plan to ",n.createElement(t.a,{href:"https://github.com/jorgecarleitao/arrow2/issues/1429"},"converge eventually"),"."),"\n",n.createElement(t.p,null,"[^2]: Apparently, if you're using the ",n.createElement(t.em,null,"Arrow")," Java library, it actually ",n.createElement(t.a,{href:"https://github.com/apache/arrow/blob/0344a2cdf6219708a25f39e580406e0ce692b61e/java/pom.xml#L1011-L1030"},"links to the C++ Parquet implementation")," via the Java Native Interface (JNI) instead of using ",n.createElement(t.code,null,"parquet-mr"),"."),"\n",n.createElement(t.h3,{id:"webassembly-performance",style:{position:"relative"}},n.createElement(t.a,{href:"#webassembly-performance","aria-label":"webassembly performance permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"WebAssembly Performance"),"\n",n.createElement(t.p,null,"Up until now I've focused on stability, but I believe that WebAssembly can bring a significant performance improvement, especially in specific cases:"),"\n",n.createElement(t.ul,null,"\n",n.createElement(t.li,null,n.createElement(t.strong,null,"A faster underlying library.")," If you're using a C library that already sees very wide usage, it's probably seen a significant investment in performance compared to your plain-JS option."),"\n",n.createElement(t.li,null,n.createElement(t.strong,null,"Binary data representation.")," If you can avoid serializing JS objects by using a binary data representation with ",n.createElement(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"},n.createElement(t.code,null,"ArrayBuffer"),"s")," instead of small JS objects, getting data into and out of WebAssembly will be much cheaper and you'll avoid tons of time in the garbage collector."),"\n",n.createElement(t.li,null,n.createElement(t.strong,null,"Vectorization.")," If you're operating on arrays of values, just moving the for loop from JS to Wasm might be significantly faster. In Python I know making a hot loop compiled can be a >10x improvement; I'm not sure exactly what speedup is likely in JS."),"\n",n.createElement(t.li,null,n.createElement(t.strong,null,"Computationally constrained.")," Algorithms are good candidates for perf improvement; if your code touches the DOM or is reliant on network requests, it won't get any faster in Wasm."),"\n"),"\n",n.createElement(t.p,null,"As an anecdotal example, a quick test last year found that my Wasm Parquet reader was ",n.createElement(t.a,{href:"https://github.com/visgl/loaders.gl/issues/2144#issue-1198790864"},n.createElement(t.strong,null,n.createElement(t.em,null,"480x faster")))," than a pure-JavaScript Parquet reader. This speedup was so high because I benefited from all of the reasons above. The Rust library I used in Wasm had seen an investment on performance and it loaded data into ",n.createElement(t.a,{href:"https://arrow.apache.org/"},"Apache Arrow"),", an efficient in-memory representation. In contrary, the JS library was newer and performed a costly transpose from Parquet's native columnar layout to an inefficient row-based layout of pure-JS objects."),"\n",n.createElement(t.p,null,"But my point is that by binding to Rust I got these performance optimizations for free! I didn't have to put in a year of work; I got to such fast performance over a few weeks of hacking nights and weekends."),"\n",n.createElement(t.p,null,"Keep in mind that WebAssembly will not magically improve performance in all cases! A good case story here is Zaplib's post-mortem, which found ",n.createElement(t.a,{href:"https://zaplib.com/docs/blog_post_mortem.html#js-vs-rust"},"meager performance improvements")," in their specific use case."),"\n",n.createElement(t.h3,{id:"so-should-we-bring-geos-to-wasm",style:{position:"relative"}},n.createElement(t.a,{href:"#so-should-we-bring-geos-to-wasm","aria-label":"so should we bring geos to wasm permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"So.. Should we bring GEOS to Wasm?"),"\n",n.createElement(t.p,null,"I brought up the Parquet analogy above because I think it applies well to the geospatial context. Geo algorithms are complex; without diving into a computational geometry textbook I'd have no idea how to implement a ",n.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Buffer_analysis"},"buffering algorithm")," from scratch."),"\n",n.createElement(t.p,null,"Similar to Parquet, in geospatial we have core, low-level libraries that have done the hard work for us. ",n.createElement(t.a,{href:"https://github.com/locationtech/jts"},"JTS")," in Java and ",n.createElement(t.a,{href:"https://github.com/libgeos/geos"},"GEOS")," in C++ have existed for around two decades and are very stable! Essentially every geometry library in a higher level language is a binding to GEOS. E.g. Shapely in Python and ",n.createElement(t.code,null,"sf")," in R. Rust has a burgeoning project, ",n.createElement(t.a,{href:"https://georust.org/"},"GeoRust"),", that will get more stable over time."),"\n",n.createElement(t.p,null,"Turf and JSTS absolutely have their use cases. For one, they exist today! They're relatively widely used already! But they're also hard to maintain; Turf's activity and contributor base ",n.createElement(t.a,{href:"https://github.com/Turfjs/turf/graphs/contributors"},"seem to have waned over the years"),"."),"\n",n.createElement(t.p,null,"Looking down the road, I think there's absolutely a case to bring GEOS or GeoRust to Wasm. GEOS is and GeoRust has the potential to be rock-solid stable libraries. I would ",n.createElement(t.em,null,"suspect")," they both have potential for performance gains in Wasm over a JS library."),"\n","\n",n.createElement(t.p,null,"For the point of discussion, let's consider for now that we've decided to write GEOS bindings for WebAssembly. We'll come back to GeoRust at the end."),"\n",n.createElement(t.h2,{id:"implementing-geos-in-webassembly",style:{position:"relative"}},n.createElement(t.a,{href:"#implementing-geos-in-webassembly","aria-label":"implementing geos in webassembly permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Implementing GEOS in WebAssembly"),"\n",n.createElement(t.h3,{id:"ease-of-binding",style:{position:"relative"}},n.createElement(t.a,{href:"#ease-of-binding","aria-label":"ease of binding permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Ease of binding"),"\n",n.createElement(t.p,null,"GEOS is written in C++, which means that the usual way to compile it to WebAssembly is to use ",n.createElement(t.a,{href:"https://emscripten.org/"},"Emscripten"),". In terms of implementation, Christoph's prototype looks like the way to go. You have to tell emscripten to ",n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm/blob/71366852768c105f701e351d17ca90ea4809409f/GEOS_EMCC_FLAGS.mk#L25-L35"},"expose the underlying C functions")," publicly from the Wasm module. Then ",n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm/blob/71366852768c105f701e351d17ca90ea4809409f/src/allCFunctions.mjs#L11-L24"},"register those functions")," from JS."),"\n",n.createElement(t.p,null,"But at that point you're stuck dealing with low level C functions and managing raw pointers. E.g. to buffer a geometry you have to ",n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm/blob/71366852768c105f701e351d17ca90ea4809409f/src/allJsFunctions/Buffer.mjs#L182"},"instantiate the GEOS Geometry object"),", ",n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm/blob/71366852768c105f701e351d17ca90ea4809409f/src/allJsFunctions/Buffer.mjs#L185-L189"},"call the GEOS buffer operation"),", and then remember to free the memory later. It's a very manual process and, indeed, quite error prone."),"\n",n.createElement(t.p,null,"As Christoph ",n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm#background"},"notes"),":"),"\n",n.createElement(t.blockquote,null,"\n",n.createElement(t.p,null,"What I naïvely expected was that once you'd get GEOS to compile to WASM, you'd automatically be able to use its functions from within JS. But that's not the case. You still need to manually expose each function you'd want to use, define the parameters and return types, allocate memory and clean up after yourself. This is a lot of work and it's far too easy to mess up and produce code that is much slower than necessary when you're not skilled enough in C. Plus, it misses the original idea of having code which is close to the source. Since we're writing the wrapper functions, there's now another layer that potentially introduces bugs, and most importantly, that needs to be maintained."),"\n"),"\n",n.createElement(t.p,null,"Yep, that's very on the nose! The difficulty of writing bindings depends on whether you want to make it easy for yourself, the developer, or easy for the user! You could expose a very low level API that forces the user to manage pointers, or put effort into writing user-friendly high-level functions."),"\n",n.createElement(t.p,null,"This is akin to the ",n.createElement(t.a,{href:"https://gdal.org/api/python_bindings.html"},"GDAL Python bindings")," vs the ",n.createElement(t.a,{href:"https://github.com/Toblerity/Fiona"},"Fiona library"),". They both bind to GDAL's vector IO, but the latter is much higher level than the former because Fiona's developers put in the work to abstract away the C interface, and so Fiona is much easier to use."),"\n",n.createElement(t.h3,{id:"performance",style:{position:"relative"}},n.createElement(t.a,{href:"#performance","aria-label":"performance permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Performance"),"\n",n.createElement(t.p,null,"Christoph further ",n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm#background"},"notes"),":"),"\n",n.createElement(t.blockquote,null,"\n",n.createElement(t.p,null,"And the buffer function is not faster than turf's, at least not in the tests I ran. I guess this is mostly due to the fact that I'm currently serialzing the GeoJSON geometry to WKT, then passing it to the WASM context, running the buffer op and then doing the same thing backwards. This is a lot of overhead, and I haven't come up with a way to avoid it."),"\n"),"\n",n.createElement(t.h4,{id:"serialization-is-costly",style:{position:"relative"}},n.createElement(t.a,{href:"#serialization-is-costly","aria-label":"serialization is costly permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Serialization is costly!"),"\n",n.createElement(t.p,null,"In any binding you have to consider the cost of moving objects across the C boundary and ideally figure out ways to reduce it."),"\n",n.createElement(t.p,null,"In Python, Python objects can read outside memory not defined by Python, and non-Python code can read Python objects (as long as it acquires the Global Interpreter Lock)."),"\n",n.createElement(t.p,null,"But WebAssembly is ",n.createElement(t.em,null,"more constrained")," than Python. While it's possible (though complex) for JavaScript to read objects from the Wasm memory space directly, the Wasm memory is sandboxed! This means that Wasm can't read ",n.createElement(t.em,null,"JavaScript's")," memory directly; rather any data required by the Wasm program must be copied from JS."),"\n",n.createElement(t.p,null,"Moving data between JS and Wasm is in effect the same as moving data between JS and a Web Worker. There are two options:"),"\n",n.createElement(t.ul,null,"\n",n.createElement(t.li,null,"A ",n.createElement(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/structuredClone"},'"structured clone"'),". This is able to copy virtually any JS object, but it's expensive; akin to ",n.createElement(t.code,null,"JSON.stringify"),"."),"\n",n.createElement(t.li,null,"However some objects are ",n.createElement(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects"},n.createElement(t.em,null,"transferable")),". This means that they can be shared ",n.createElement(t.em,null,"freely")," either between the main thread and a web worker or, in this case, across the Wasm boundary. Transfering an object is free because it's essentially just changing the ownership of a pointer. This also means that ",n.createElement(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects#supported_objects"},"few objects")," meet this criteria: mainly just ",n.createElement(t.code,null,"ArrayBuffer"),"s."),"\n"),"\n",n.createElement(t.p,null,"In Christoph's prototype, it:"),"\n",n.createElement(t.ul,null,"\n",n.createElement(t.li,null,"Uses a JS library to ",n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm/blob/8c2679536bd33205377b6359a2e7bdc03d69db14/src/allJsFunctions/Buffer.mjs#L182"},"serialize every input GeoJSON to WKT"),"."),"\n",n.createElement(t.li,null,"Then ",n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm/blob/8c2679536bd33205377b6359a2e7bdc03d69db14/src/allJsFunctions/Buffer.mjs#L182"},"passes the WKT string to ",n.createElement(t.code,null,"GEOSGeomFromWKT")),". This first copies the string to Wasm memory using a structured clone. Then GEOS parses the WKT into a GEOS object and returns to JS the pointer in Wasm memory to the GEOS object."),"\n",n.createElement(t.li,null,"Then after the GEOS operation, it ",n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm/blob/8c2679536bd33205377b6359a2e7bdc03d69db14/src/allJsFunctions/Buffer.mjs#L195"},"passes the pointer of the new GEOS object")," to ",n.createElement(t.code,null,"GEOSGeomToWKT"),". This does the reverse of the last point: it encodes into a WKT string, then copies that string out of Wasm memory back to JS."),"\n",n.createElement(t.li,null,"Then ",n.createElement(t.a,{href:"https://github.com/chrispahm/geos-wasm/blob/8c2679536bd33205377b6359a2e7bdc03d69db14/src/allJsFunctions/Buffer.mjs#L195"},"decodes the WKT back to a GeoJSON"),"."),"\n"),"\n",n.createElement(t.p,null,"This is ",n.createElement(t.em,null,"hugely inefficient"),". That's not to say there's an easy way around it! Using WKB instead of WKT would probably provide a small speedup, but when every part of the process needs a different memory representation, the interchange between each is going to have overhead!"),"\n",n.createElement(t.h4,{id:"vectorization",style:{position:"relative"}},n.createElement(t.a,{href:"#vectorization","aria-label":"vectorization permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Vectorization"),"\n",n.createElement(t.p,null,"Pretty much any binding that operates on ",n.createElement(t.em,null,"individual")," items at a time will be slow. Shapely version 2 is ",n.createElement(t.em,null,"much, much")," faster than Shapely version 1 because it's vectorized. That is, it operates on arrays of objects at a time instead of one at a time."),"\n",n.createElement(t.p,null,"I doubt GEOS would ever be faster than JSTS or Turf for single geometries because the constant portion of overhead can't be amortized across a bunch of computations."),"\n",n.createElement(t.p,null,"To make GEOS vectorized in Wasm would mean you'd have an array of heap allocated pointers in Wasm memory space. It could definitely be done but it would require extra binding code on the C side to provide vectorized functions."),"\n",n.createElement(t.h3,{id:"licensing",style:{position:"relative"}},n.createElement(t.a,{href:"#licensing","aria-label":"licensing permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Licensing"),"\n",n.createElement(t.p,null,'GEOS is licensed under the LGPL 2.1. This effectively means that any code that is statically linked\nto GEOS must also be licensed as LGPL. I am not a lawyer, and the legal definition of "linking"\nfeels murky at times. But enforcing dynamic linking in WebAssembly sounds like a black hole. If that\nwere necessary to prevent having to open source all an application\'s frontend code, that would\nsignificantly decrease the potential audience of the project.'),"\n",n.createElement(t.h2,{id:"georust",style:{position:"relative"}},n.createElement(t.a,{href:"#georust","aria-label":"georust permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"GeoRust?"),"\n",n.createElement(t.p,null,"I want to come back to GeoRust before closing my thoughts, because I'm really excited about its potential. Let's look at each of the points above and consider how using GeoRust might impact them."),"\n",n.createElement(t.h3,{id:"ease-of-binding-1",style:{position:"relative"}},n.createElement(t.a,{href:"#ease-of-binding-1","aria-label":"ease of binding 1 permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Ease of binding"),"\n",n.createElement(t.p,null,"WebAssembly was one of the original use cases for Rust at Mozilla, so unsurprisingly Rust is extremely well suited for Wasm. If your dependencies are pure-Rust, all it takes is a ",n.createElement(t.code,null,"wasm-pack build")," and you have your bundle! C dependencies from Rust can get hairy, but since GeoRust is pure Rust, this is not an issue."),"\n",n.createElement(t.p,null,"And since the compiler verifies the safety of your code at compile time, if it compiled, it's very likely to work out of the box in JS!"),"\n",n.createElement(t.h3,{id:"performance-1",style:{position:"relative"}},n.createElement(t.a,{href:"#performance-1","aria-label":"performance 1 permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Performance"),"\n",n.createElement(t.h4,{id:"serialization",style:{position:"relative"}},n.createElement(t.a,{href:"#serialization","aria-label":"serialization permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Serialization"),"\n",n.createElement(t.p,null,n.createElement(t.a,{href:"#serialization-is-costly"},"Above I said"),":"),"\n",n.createElement(t.blockquote,null,"\n",n.createElement(t.p,null,"when every part of the process needs a different memory representation, the interchange between each is going to have overhead"),"\n"),"\n",n.createElement(t.p,null,"To get around this, we need to have every step of the process use the same memory representation! This why I believe so strongly in ",n.createElement(t.a,{href:"https://github.com/geoarrow/geoarrow"},"GeoArrow"),". It defines a single memory layout that is usable ",n.createElement(t.em,null,"across languages"),". Because Arrow has the ",n.createElement(t.em,null,"exact same memory layout")," in every implementation, it enables JavaScript to ",n.createElement(t.a,{href:"https://observablehq.com/@kylebarron/zero-copy-apache-arrow-with-webassembly"},"correctly interpret memory from the WebAssembly memory space")," ",n.createElement(t.em,null,"without any serialization"),", even avoiding a copy in some cases. Then in turn we can ",n.createElement(t.a,{href:"https://observablehq.com/@kylebarron/geoarrow-and-geoparquet-in-deck-gl"},"visualize the GeoArrow arrays in deck.gl")," with only a copy to the GPU."),"\n",n.createElement(t.p,null,"Rust has a feature called ",n.createElement(t.a,{href:"https://doc.rust-lang.org/book/ch10-02-traits.html"},n.createElement(t.em,null,"traits")),". Essentially a way to define that any object out there — even one a library author has never seen before — that supplies a set of pre-defined methods can be used with the same algorithms. What this means is that if we define a common trait for how GeoRust accesses coordinate data from geometries, then GeoRust's algorithms could operate on GeoArrow memory without any serialization!"),"\n",n.createElement(t.p,null,"I've been ",n.createElement(t.a,{href:"https://github.com/georust/geo/pull/1011"},"slowly pushing this along")," in GeoRust. It'll take a while to figure out how to adapt GeoRust's algorithms for the trait model, but if it works out it'll make things really fast and memory efficient."),"\n","\n",n.createElement(t.p,null,"This is why having a binary geometry encoding is so valuable. It's free to move across thread boundaries."),"\n",n.createElement(t.p,null,"Here GeoArrow makes moving data into Wasm extremely cheap and reading it out of WASM virtually free.  --\x3e"),"\n",n.createElement(t.h3,{id:"licensing-1",style:{position:"relative"}},n.createElement(t.a,{href:"#licensing-1","aria-label":"licensing 1 permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Licensing"),"\n",n.createElement(t.p,null,"GeoRust is licensed as MIT, so there are no license concerns."),"\n",n.createElement(t.h3,{id:"but-its-incomplete",style:{position:"relative"}},n.createElement(t.a,{href:"#but-its-incomplete","aria-label":"but its incomplete permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"But it's incomplete?"),"\n",n.createElement(t.p,null,"Yes, this is true, it is incomplete! For example, GeoRust ",n.createElement(t.a,{href:"https://github.com/georust/geo/issues/641"},"doesn't currently have an implementation of buffering")," (as of June 2023). And surely other algorithms in GEOS haven't yet been ported. (Though ",n.createElement(t.a,{href:"https://docs.rs/geo/latest/geo/#algorithms"},"the algorithms that do exist")," are very high quality.)"),"\n",n.createElement(t.p,null,"To be clear, the time horizon to maturity is certainly longer for GeoRust because it's newer.\nIt will take GeoRust some time to catch up to the full suite of operations in JTS/GEOS, but I have faith in the project and the community that it will happen."),"\n",n.createElement(t.p,null,"Ideally if more downstream projects pop up that use GeoRust, it will create a symbiotic relationship that's great for the whole ecosystem. Just as GEOS sees development interest resulting from the huge number of downstream users in e.g. Shapely, so would GeoRust hopefully see more contributors if there were a larger transitive user base."),"\n",n.createElement(t.h2,{id:"where-to-go-from-here",style:{position:"relative"}},n.createElement(t.a,{href:"#where-to-go-from-here","aria-label":"where to go from here permalink",className:"anchor before"},n.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Where to go from here?"),"\n",n.createElement(t.p,null,"So in conclusion... will I be spending my time writing GEOS bindings to Wasm? No, that's unlikely. (Also I don't know C!) But if I find time in the future, I'd jump on the chance to bring GeoRust to the browser."),"\n",n.createElement(t.p,null,"The truth is,\n",n.createElement(t.strong,null,"I'm more bullish about the unrealized potential of GeoRust + GeoArrow applied to WebAssembly and Python than any other technology combination on the horizon today.")),"\n",n.createElement(t.p,null,"If you need something in the next 6 months, invest in geos-wasm. If you're looking a couple years down the road, maybe consider GeoRust."))}var l=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.RP)(),e.components);return t?n.createElement(t,e,n.createElement(o,e)):o(e)},i=a(1173);function s(e){return n.createElement(i.A,e,n.createElement(l,e))}i.A},7169:function(e,t,a){var n=a(6540),r=a(4810),o=a(7533);t.A=e=>{let{title:t="",description:a="",pathname:l="",image:i="",children:s=null,canonicalUrl:c=""}=e;const h=(0,o.A)(),{siteTitle:m,siteTitleAlt:u,siteUrl:p,siteDescription:d,siteImage:g,author:f,siteLanguage:b}=h,y={title:t?t+" | "+m:u,description:a||d,url:""+p+(l||""),image:""+p+(i||g)};return n.createElement(n.Fragment,null,n.createElement("html",{lang:b}),n.createElement("title",null,y.title),n.createElement("meta",{name:"description",content:y.description}),n.createElement("meta",{name:"image",content:y.image}),n.createElement("meta",{property:"og:title",content:y.title}),n.createElement("meta",{property:"og:url",content:y.url}),n.createElement("meta",{property:"og:description",content:y.description}),n.createElement("meta",{property:"og:image",content:y.image}),n.createElement("meta",{property:"og:type",content:"website"}),n.createElement("meta",{property:"og:image:alt",content:y.description}),n.createElement("meta",{name:"twitter:card",content:"summary_large_image"}),n.createElement("meta",{name:"twitter:title",content:y.title}),n.createElement("meta",{name:"twitter:url",content:y.url}),n.createElement("meta",{name:"twitter:description",content:y.description}),n.createElement("meta",{name:"twitter:image",content:y.image}),n.createElement("meta",{name:"twitter:image:alt",content:y.description}),n.createElement("meta",{name:"twitter:creator",content:f}),n.createElement("meta",{name:"gatsby-theme",content:"@lekoarts/gatsby-theme-minimal-blog"}),n.createElement("link",{rel:"icon",type:"image/png",sizes:"32x32",href:(0,r.Fe)("/favicon-32x32.png")}),n.createElement("link",{rel:"icon",type:"image/png",sizes:"16x16",href:(0,r.Fe)("/favicon-16x16.png")}),n.createElement("link",{rel:"apple-touch-icon",sizes:"180x180",href:(0,r.Fe)("/apple-touch-icon.png")}),c?n.createElement("link",{rel:"canonical",href:c}):null,s)}},7715:function(e,t,a){var n=a(9894),r=a(6540),o=a(4810),l=a(3601),i=a(2174);t.A=e=>{let{tags:t}=e;const{tagsPath:a,basePath:s}=(0,l.A)();return(0,n.Y)(r.Fragment,null,t.map((e,t)=>(0,n.Y)(r.Fragment,{key:e.slug},!!t&&", ",(0,n.Y)(o.N_,{sx:e=>{var t;return Object.assign({},null===(t=e.styles)||void 0===t?void 0:t.a)},to:(0,i.A)("/"+s+"/"+a+"/"+e.slug)},e.name))))}}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-geos-wasm-index-mdx-1101251da832fb01616d.js.map